--[[
Iptables file dumper for Alpine Wall
Copyright (C) 2012-2024 Kaarle Ritvanen
See LICENSE file for license details
]]--


local class = require('awall.class')
local ACTIVE = require('awall.family').ACTIVE
local raise = require('awall.uerror').raise

local util = require('awall.util')
local printmsg = util.printmsg
local sortedkeys = util.sortedkeys


local lpc = require('lpc')
local posix = require('posix')
local startswith = require('stringy').startswith


local M = {}

local backupdir = '/var/run/awall'

local families = {
	inet={cmd='iptables', file='rules-save'},
	inet6={cmd='ip6tables', file='rules6-save'}
}

local builtin = {
	filter={'FORWARD', 'INPUT', 'OUTPUT'},
	mangle={'FORWARD', 'INPUT', 'OUTPUT', 'POSTROUTING', 'PREROUTING'},
	nat={'INPUT', 'OUTPUT', 'POSTROUTING', 'PREROUTING'},
	raw={'OUTPUT', 'PREROUTING'},
	security={'FORWARD', 'INPUT', 'OUTPUT'}
}

function M.isbuiltin(tbl, chain) return util.contains(builtin[tbl], chain) end


local BaseIPTablesRuleset = class()

function BaseIPTablesRuleset:print()
	for _, family in sortedkeys(families) do
		self:dumpfile(family, io.output())
		io.write('\n')
	end
end

function BaseIPTablesRuleset:dump(dir)
	for family, tbls in pairs(families) do
		local name = dir..'/'..families[family].file
		local file = io.open(name, 'w')
		if not file then raise('Cannot write to '..name) end
		self:dumpfile(family, file)
		file:close()
	end
end

function BaseIPTablesRuleset:restorecmd(family, test)
	local cmd = {families[family].cmd..'-restore'}
	if test then table.insert(cmd, '-t') end
	return table.unpack(cmd)
end

function BaseIPTablesRuleset:restore(test)
	for _, family in ipairs(actfamilies()) do
		local pid, stdin, stdout = lpc.run(self:restorecmd(family, test))
		stdout:close()
		self:dumpfile(family, stdin)
		stdin:close()
		assert(lpc.wait(pid) == 0)
	end
end

function BaseIPTablesRuleset:activate()
	self:flush()
	self:restore(false)
end

function BaseIPTablesRuleset:test() self:restore(true) end

function BaseIPTablesRuleset:flush() M.flush() end


M.IPTablesRuleset = class(BaseIPTablesRuleset)

function M.IPTablesRuleset:init()
	local function nestedtable(levels)
		return levels > 0 and setmetatable(
			{},
			{
				__index=function(t, k)
					t[k] = nestedtable(getmetatable(t).levels - 1)
					return t[k]
				end,
				levels=levels
			}
		) or {}
	end
	self.rules = nestedtable(3)
end

function M.IPTablesRuleset:dumpfile(family, iptfile)
	iptfile:write('# '..families[family].file..' generated by awall\n')
	local tables = self.rules[family]
	for _, tbl in sortedkeys(tables) do
		iptfile:write('*'..tbl..'\n')
		local chains = tables[tbl]
		for _, chain in sortedkeys(chains) do
			local policy = '-'
			if M.isbuiltin(tbl, chain) then
				policy = tbl == 'filter' and 'DROP' or 'ACCEPT'
			end
			iptfile:write(':'..chain..' '..policy..' [0:0]\n')
		end
		for _, chain in sortedkeys(chains) do
			for _, rule in ipairs(chains[chain]) do
				iptfile:write('-A '..chain..' '..rule..'\n')
			end
		end
		iptfile:write('COMMIT\n')
	end
end


M.PartialIPTablesRuleset = class(M.IPTablesRuleset)

function M.PartialIPTablesRuleset:restorecmd(family, test)
	local cmd = {M.PartialIPTablesRuleset.super(self):restorecmd(family, test)}
	table.insert(cmd, '-n')
	return table.unpack(cmd)
end

function M.PartialIPTablesRuleset:dumpfile(family, iptfile)
	local tables = self.rules[family]
	for tbl, chains in pairs(tables) do
		local builtins = {}
		for chain, _ in pairs(chains) do
			if startswith(chain, 'awall-') then
				local base = chain:sub(7, -1)
				if M.isbuiltin(tbl, base) then table.insert(builtins, base) end
			end
		end
		for _, chain in ipairs(builtins) do
			chains[chain] = {'-j awall-'..chain}
		end
	end
	M.PartialIPTablesRuleset.super(self):dumpfile(family, iptfile)
end

function M.PartialIPTablesRuleset:flush()
	for _, family in ipairs(actfamilies()) do
		local cmd = families[family].cmd
		for _, tbl in ipairs(acttables(family)) do
			if builtin[tbl] then
				local pid, stdin, stdout = lpc.run(cmd, '-t', tbl, '-S')
				stdin:close()
				local chains = {}
				local rules = {}
				for line in stdout:lines() do
					if startswith(line, '-N awall-') then
						table.insert(chains, line:sub(4, -1))
					else
						local chain, target = line:match(
							'^%-A (%u+) %-j (awall%-%u+)$'
						)
						if chain then
							table.insert(rules, {chain, '-j', target})
						end
					end
				end
				stdout:close()
				assert(lpc.wait(pid) == 0)

				local function exec(...)
					assert(util.execute(cmd, '-t', tbl, table.unpack{...}) == 0)
				end
				for _, rule in ipairs(rules) do
					exec('-D', table.unpack(rule))
				end
				for _, opt in ipairs{'-F', '-X'} do
					for _, chain in ipairs(chains) do exec(opt, chain) end
				end
			end
		end
	end
end


local CurrentRuleset = class(BaseIPTablesRuleset)

function CurrentRuleset:dumpfile(family, iptfile)
	local pid, stdin, stdout = lpc.run(families[family].cmd..'-save')
	stdin:close()
	for line in stdout:lines() do iptfile:write(line..'\n') end
	stdout:close()
	assert(lpc.wait(pid) == 0)
end


local BackupRuleset = class(BaseIPTablesRuleset)

function BackupRuleset:dumpfile(family, iptfile)
	for line in io.lines(backupdir..'/'..families[family].file) do
		iptfile:write(line..'\n')
	end
end


local _acttables = {}
local function acttables(family)
	if not _acttables[family] then
		_acttables[family] = {}
		local pid, stdin, stdout = lpc.run(families[family].cmd..'-save')
		stdin:close()
		for line in stdout:lines() do
			local tbl = string.match(line, "^%*(.*)")
			if tbl then table.insert(_acttables[family], tbl) end
		end
		stdout:close()
		assert(lpc.wait(pid) == 0)
	end
	return _acttables[family]
end


local _actfamilies
local function actfamilies()
	if _actfamilies then return _actfamilies end
	_actfamilies = {}
	for _, family in ipairs(ACTIVE) do
		if #acttables(family) > 0 then table.insert(_actfamilies, family)
		else printmsg('Warning: firewall not enabled for '..family) end
	end
	return _actfamilies
end

function M.isenabled() return #actfamilies() > 0 end

function M.backup()
	posix.mkdir(backupdir)
	CurrentRuleset():dump(backupdir)
end

function M.revert() BackupRuleset():activate() end

function M.flush()
	local empty = M.IPTablesRuleset()
	for _, family in pairs(actfamilies()) do
		for _, tbl in ipairs(acttables(family)) do
			if builtin[tbl] then
				for _, chain in ipairs(builtin[tbl]) do
					empty.rules[family][tbl][chain] = {}
				end
			else printmsg('Warning: not flushing unknown table: '..tbl) end
		end
	end
	empty:restore(false)
end

return M

-- vim: ts=4
